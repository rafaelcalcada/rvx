{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"RVX Documentation","text":""},{"location":"#h2-homepage-no-top-margin","title":"Welcome to RVX DocumentationGet Started","text":"<p>RVX is a microcontroller IP core developed in Verilog that implements the RV32I instruction set of RISC-V. It is designed for easy, seamless integration into embedded systems and FPGA designs, facilitating the rapid development of innovative RISC-V applications.</p> <p>RVX can run real-time operating systems such as FreeRTOS, as well as bare-metal embedded software. Its design includes components such as memory, timers, and interfaces for UART, GPIO, and SPI communication, enabling RVX to integrate with a variety of sensors and actuators commonly used in embedded applications.</p> <p>The quickest way to get started is to implement one of the example projects on your FPGA. Check it out:</p> <ul> <li>Hello World Example </li> <li>FreeRTOS Example</li> </ul> <p>See the User Guide to learn how to create your own applications.</p> <p> </p>"},{"location":"hardware/","title":"RVX Hardware Docs","text":""},{"location":"hardware/#introduction","title":"Introduction","text":"<p>RVX is a microcontroller IP core developed in Verilog that implements the RV32I instruction set of RISC-V. It is designed for easy, seamless integration into embedded systems and FPGA designs, facilitating the rapid development of innovative RISC-V applications.</p> <p>RVX can run real-time operating systems such as FreeRTOS, as well as bare-metal embedded software. Its design includes components such as memory, timers, and interfaces for UART, GPIO, and SPI communication, enabling RVX to integrate with a variety of sensors and actuators commonly used in embedded applications.</p> <p>For information on how to develop a new application with RVX, see the User Guide.</p> <p>RVX implements the following features of the RISC-V specifications:</p> <ul> <li>the RV32I Base Integer Instruction Set, <code>v2.1</code></li> <li>the Zicsr Extension for Control and Status Register (CSR) Instructions, <code>v2.0</code></li> <li>the Machine-Level ISA, <code>v1.13</code></li> </ul>"},{"location":"hardware/#architecture","title":"Architecture","text":"<p>A top-level view of RVX architecture is presented in the diagram below.</p> <p></p> Figure 1. RVX Architecture"},{"location":"hardware/#source-files","title":"Source Files","text":"<p>The source files of RVX are saved in the <code>hardware/</code> folder of its repository.</p>"},{"location":"hardware/#configuration","title":"Configuration","text":"<p>The table below lists the configuration parameters of RVX Top Module, <code>rvx.v</code>:</p> Parameter name and description Value type Default value BOOT_ADDRESSMemory address of the first instruction to be fetched and executed. 32-bit hexadecimal <code>32'h00000000</code> CLOCK_FREQUENCYFrequency (in Hertz) of the <code>clock</code> input signal. Integer <code>50000000</code> UART_BAUD_RATEBaud rate of the UART module (in bauds per second). Integer <code>9600</code> MEMORY_SIZESize of the memory module (in bytes). Integer <code>8192</code> MEMORY_INIT_FILEAbsolute path to the memory initialization file. String <code>(empty string)</code> GPIO_WIDTHNumber of general-purpose I/O pins. Integer <code>1</code> SPI_NUM_CHIP_SELECTNumber of Chip Select (CS) lines for the SPI Controller. Integer <code>1</code>"},{"location":"hardware/#io-signals","title":"I/O Signals","text":"<p>The input/output signals of RVX Top Module, <code>rvx.v</code>, are listed in the table below:</p> Pin name and description Direction Size clockClock input. Input 1 bit resetReset pin (active-high). Input 1 bit haltHalt pin (active-high). Input 1 bit uart_rxUART receiver pin. Input 1 bit uart_txUART transmitter pin. Output 1 bit gpio_inputGPIO input signals. Input <code>GPIO_WIDTH</code> gpio_oeGPIO output enable. Output <code>GPIO_WIDTH</code> gpio_outputGPIO output signals. Output <code>GPIO_WIDTH</code> sclkSPI Controller clock. Output 1 bit picoSPI Peripheral In Controller Out. Output 1 bit pociSPI Peripheral Out Controller In. Input 1 bit csSPI Chip Select lines. Output <code>SPI_NUM_CHIP_SELECT</code>"},{"location":"hardware/#memory-map","title":"Memory Map","text":"<p>The devices in RVX are mapped to memory addresses as detailed below:</p> Start address Final address Range size (Bytes) Device <code>0x00000000</code> <code>0x(MEMORY_SIZE-1)</code> <code>MEMORY_SIZE</code> RAM <code>0x80000000</code> <code>0x8000000f</code> 16 UART Controller <code>0x80010000</code> <code>0x8001001f</code> 32 Timer <code>0x80020000</code> <code>0x8002001f</code> 32 GPIO Controller <code>0x80030000</code> <code>0x8003001f</code> 32 SPI Controller <p> </p>"},{"location":"userguide/","title":"User Guide","text":""},{"location":"userguide/#introduction","title":"Introduction","text":"<p>The process of developing a new application with RVX involves two main steps:</p> <ol> <li> <p>Building the application</p> <p>The first step is to write the source code for the new application and build it with the RISC-V GNU Toolchain. The build process generates a <code>.hex</code> file that is later used to initialize the memory of RVX.</p> </li> <li> <p>Running on an FPGA</p> <p>Once you have built the application, you can run it on RVX. To do this, you need to implement an instance of RVX on an FPGA and initialize it with the <code>.hex</code> file generated in the first step.</p> </li> </ol>"},{"location":"userguide/#prerequisites","title":"Prerequisites","text":"<p>To build software for RISC-V you need the RISC-V GNU Toolchain, a suite of compilers and development tools for the RISC-V architecture. </p> <p>Run the commands below to install and configure the RISC-V GNU Toolchain for RVX:</p> 1. Clone the RISC-V GNU Toolchain repository<pre><code>git clone https://github.com/riscv-collab/riscv-gnu-toolchain\n</code></pre> UbuntuFedora/CentOS/RHEL/RockyArch LinuxOS X 2. Install dependencies (Ubuntu)<pre><code>sudo apt-get install \\\n    autoconf automake autotools-dev curl python3 python3-pip libmpc-dev libmpfr-dev \\\n    libgmp-dev gawk build-essential bison flex texinfo gperf libtool patchutils bc \\\n    zlib1g-dev libexpat-dev ninja-build git cmake libglib2.0-dev libslirp-dev\n</code></pre> 2. Install dependencies (Fedora/CentOS/RHEL/Rocky)<pre><code>sudo yum install \\\n    autoconf automake python3 libmpc-devel mpfr-devel gmp-devel gawk  bison flex \\\n    texinfo patchutils gcc gcc-c++ zlib-devel expat-devel libslirp-devel\n</code></pre> 2. Install dependencies (Arch Linux)<pre><code>sudo pacman -Syyu \\\n    autoconf automake curl python3 libmpc mpfr gmp gawk base-devel bison flex texinfo \\\n    gperf libtool patchutils bc zlib expat libslirp\n</code></pre> 2. Install dependencies (OS X)<pre><code>brew install python3 gawk gnu-sed gmp mpfr libmpc isl zlib expat texinfo flock libslirp\n</code></pre> 3. Configure the RISC-V GNU Toolchain for RVX<pre><code>cd riscv-gnu-toolchain &amp;&amp; ./configure --with-arch=rv32izicsr --with-abi=ilp32 --prefix=/opt/riscv\n</code></pre> <p>Important: The <code>--prefix</code> option defines the installation folder. You need to set it to a folder where you have <code>rwx</code> permissions. The command above assumes you have <code>rwx</code> permissions on <code>/opt</code>.</p> 4. Compile and install<pre><code>make -j $(nproc)\n</code></pre>"},{"location":"userguide/#building-the-application","title":"Building the application","text":"<p>RVX offers two template projects to help you start developing new applications: a bare-metal template and a more sophisticated FreeRTOS template.</p> <p>Both templates include a <code>main.c</code> file where you place the source code for the new application. These projects use CMake to configure the RISC-V GNU Toolchain for RVX, which simplifies the process of compiling and linking the software.</p> <p>To start a new application, follow the steps below.</p> 1. Clone RVX repository<pre><code>git clone https://github.com/rafaelcalcada/rvx\n</code></pre> Bare-metalFreeRTOS 2. Copy the template project (Bare-metal)<pre><code>cp -r rvx/templates/baremetal my_project/\n</code></pre> 2. Copy the template project (FreeRTOS)<pre><code>cp -r rvx/templates/freertos my_project/\n</code></pre> <p>Find the <code>main.c</code> file in the project folder and write the code for the new application in this file.</p> Bare-metalFreeRTOS 3. Build the application (Bare-metal)<pre><code>cd my_project/ &amp;&amp; make PREFIX=/opt/riscv\n</code></pre> 3. Build the application (FreeRTOS)<pre><code>cd my_project/ &amp;&amp; make PREFIX=/opt/riscv CLOCK_FREQUENCY=&lt;freq_in_hertz&gt;\n</code></pre> <p>The <code>PREFIX</code> variable must specify the folder where the RISC-V GNU Toolchain is installed. For the FreeRTOS template, you also need to set the <code>CLOCK_FREQUENCY</code> variable to match the clock frequency of the FPGA board where the application will run.</p> <p>A successfull build ends with a message like this:</p> Successful build report<pre><code>Memory init file:   build/freertos.hex\nBinary executable:  build/freertos.elf\nDisassembly:        build/freertos.objdump\n\nMemory usage report (MEMORY_SIZE = 32K)\n      text       data        bss      total filename\n     14092        304       9196      23592 freertos.elf\n</code></pre> <p>The <code>.hex</code> file generated by the build process will be used in the next step to initialize the memory of RVX.</p>"},{"location":"userguide/#running-on-an-fpga","title":"Running on an FPGA","text":"<p>Once you have generated the <code>.hex</code> file you can implement RVX on an FPGA to run the application. This process consists of two steps:</p> <ul> <li> <p>First, create a wrapper module that includes an instance of RVX, configure it for the target FPGA, and initialize it with the application to be run using the <code>.hex</code> file.</p> </li> <li> <p>Next, use the EDA software provided by your FPGA vendor to synthesize the wrapper module and program the FPGA with it.</p> </li> </ul> 1. Creating the wrapper module <p>Using your preferred text editor, create a Verilog file called <code>rvx_wrapper.v</code> and add the code provided below. Make sure to modify the file according to the instructions in the comments.</p> rvx_wrapper.v<pre><code>module rvx_wrapper (\n\n  input   wire          clock       ,\n  input   wire          reset       ,\n  input   wire          halt        ,\n\n  // UART pins\n  // You can remove them if your application does not use the UART controller\n  input   wire          uart_rx     ,\n  output  wire          uart_tx     ,\n\n  // General Purpose I/O pins\n  // You can remove them if your application does not use the GPIO controller\n  input   wire  [3:0]   gpio_input  ,\n  output  wire  [3:0]   gpio_oe     ,\n  output  wire  [3:0]   gpio_output ,\n\n  // Serial Peripheral Interface (SPI) pins\n  // You can remove them if your application does not use the SPI controller\n  output  wire          sclk        ,\n  output  wire          pico        ,\n  input   wire          poci        ,\n  output  wire  [0:0]   cs\n\n  );\n\n  reg reset_debounced;\n  always @(posedge clock) reset_debounced &lt;= reset;\n\n  reg halt_debounced;\n  always @(posedge clock) halt_debounced &lt;= halt;\n\n  rvx #(\n\n    // Frequency (in Hertz) of the `clock` pin\n    .CLOCK_FREQUENCY          (50000000                   ),\n\n    // Absolute path to the .hex file generated by the build\n    .MEMORY_INIT_FILE         (\"/path/to/myapp.hex\"       ),    \n\n    // The size you want for the memory (in bytes)\n    .MEMORY_SIZE              (8192                       ),\n\n    // The UART baud rate (in bauds per second)\n    .UART_BAUD_RATE           (9600                       ),\n\n    // Don't change it unless you explicitly modified the boot address\n    .BOOT_ADDRESS             (32'h00000000               ),\n\n    // Width of the gpio_* ports\n    .GPIO_WIDTH               (4                          ),\n\n    // Width of the cs port\n    .SPI_NUM_CHIP_SELECT      (1                          ))\n\n    rvx_instance (\n\n    .clock                    (clock                      ),\n    .reset                    (reset_debounced            ),\n    .halt                     (halt_debounced             ),\n    .uart_rx                  (uart_rx                    ),\n    .uart_tx                  (uart_tx                    ),\n    .gpio_input               (gpio_input                 ),\n    .gpio_oe                  (gpio_oe                    ),\n    .gpio_output              (gpio_output                ),\n    .sclk                     (sclk                       ),\n    .pico                     (pico                       ),\n    .poci                     (poci                       ),\n    .cs                       (cs                         ));\n\nendmodule\n</code></pre> 2. Synthesizing rvx_wrapper.v <p>The steps to synthesize a Verilog module can differ based on the FPGA model and vendor, but they generally follow this sequence:</p> <ol> <li> <p>Start a new project: Open the EDA tool provided by your FPGA vendor (e.g., AMD Vivado, Intel Quartus, Lattice iCEcube).</p> </li> <li> <p>Add files to the project: Include <code>rvx_wrapper.v</code> to the project and all files in the <code>hardware/</code> folder of RVX repository.</p> </li> <li> <p>Create a design constraints file: Map the ports of <code>rvx_wrapper.v</code> to the corresponding devices on the FPGA board.</p> </li> <li> <p>Run the synthesis process: This includes placing and routing, as well as any other necessary steps to generate a bitstream for the FPGA.</p> </li> <li> <p>Generate the bitstream: Once completed, program the FPGA with the generated bitstream.</p> </li> </ol> <p>The application will start running immediately after you program the FPGA!</p> <p> </p>"},{"location":"examples/freertos/","title":"FreeRTOS Example","text":""},{"location":"examples/freertos/#introduction","title":"Introduction","text":"<p>The FreeRTOS example is a more sophisticated application that runs on top of FreeRTOS, an open-source real-time operating system. The application uses the GPIO controller of RVX to make 2 LEDs blink in a specific pattern with the help of FreeRTOS task scheduler.</p>"},{"location":"examples/freertos/#prerequisites","title":"Prerequisites","text":"<p>To run this example you need an FPGA board with at least 2 LEDs and 32KB of Block RAM.</p> <p>Additionally, you need to have the RISC-V GNU Toolchain installed on your machine to build the example. You can find instructions on how to install the RISC-V GNU Toolchain in the User Guide.</p>"},{"location":"examples/freertos/#building-the-example","title":"Building the example","text":"<p>Run the commands below to build the FreeRTOS example:</p> 1. Clone RVX repository<pre><code>git clone https://github.com/rafaelcalcada/rvx\n</code></pre> 2. Build the software for the FreeRTOS example<pre><code>cd rvx/examples/freertos/software\nmake PREFIX=/opt/riscv CLOCK_FREQUENCY=&lt;freq_in_hertz&gt;\n</code></pre> <p>The <code>PREFIX</code> variable must specify the folder where the RISC-V GNU Toolchain is installed. You also need to set the <code>CLOCK_FREQUENCY</code> variable to match the clock frequency of the FPGA board where the application will run.</p> <p>A successfull build ends with a message like this:</p> Successful build report<pre><code>Memory init file:   build/freertos.hex\nBinary executable:  build/freertos.elf\nDisassembly:        build/freertos.objdump\n\nMemory usage report (MEMORY_SIZE = 32K)\n      text       data        bss      total filename\n     14092        304       9196      23592 freertos.elf\n</code></pre> <p>The <code>freertos.hex</code> file generated by the build process will be used in the next step to initialize the memory of RVX.</p>"},{"location":"examples/freertos/#implementing-on-an-fpga","title":"Implementing on an FPGA","text":"Creating the FreeRTOS module <p>Using your preferred text editor, create a Verilog file name <code>freertos.v</code> and add the source code below. Make sure to modify <code>freertos.v</code> as follows:</p> <ul> <li>Change the <code>MEMORY_INIT_FILE</code> parameter to the absolute path of the <code>freertos.hex</code> file you generated in the previous step.</li> <li>Change the <code>CLOCK_FREQUENCY</code> parameter to the frequency (in Hertz) of the <code>clock</code> input.</li> </ul> freertos.v<pre><code>module freertos #(\n\n  parameter GPIO_WIDTH = 2\n\n  )(\n\n  input   wire clock,\n  input   wire reset,\n  output  wire [GPIO_WIDTH-1:0] gpio\n\n  );\n\n  // Reset button debouncing\n  reg reset_debounced;\n  always @(posedge clock) begin\n    reset_debounced &lt;= reset;\n  end\n\n  rvx #(\n\n  // Please adjust these parameters accordingly\n  .CLOCK_FREQUENCY          (50000000                   ),\n  .MEMORY_SIZE              (32768                      ),\n  .MEMORY_INIT_FILE         (\"/path/to/freertos.hex\"    ),\n  .GPIO_WIDTH               (GPIO_WIDTH                 )\n\n  ) rvx_instance (\n\n  .clock                    (clock                      ),\n  .reset                    (reset_debounced            ),\n  .gpio_output              (gpio                       ),\n\n  // Unused inputs need to be hardwired to zero\n  .halt                     (1'b0                       ),\n  .uart_rx                  (1'b0                       ),\n  .gpio_input               ({GPIO_WIDTH{1'b0}}         ),\n  .poci                     (1'b0                       ),\n\n  // Unused outputs can be left open\n  .uart_tx                  (                           ),  \n  .gpio_oe                  (                           ),\n  .sclk                     (                           ),\n  .pico                     (                           ),  \n  .cs                       (                           ));\n\nendmodule\n</code></pre> Synthesizing the FreeRTOS module <p>To implement the <code>freertos.v</code> module on your FPGA, follow the steps below:</p> <ol> <li> <p>Open the EDA tool provided by your FPGA vendor (e.g., AMD Vivado, Intel Quartus, Lattice iCEcube).</p> </li> <li> <p>Include <code>freertos.v</code> to the project and all files in the <code>hardware/</code> folder of RVX repository.</p> </li> <li> <p>Create a design constraints file and map the ports of <code>freertos.v</code> to the corresponding devices on the FPGA board.</p> <ul> <li>Map the <code>gpio</code> outputs to 2 LEDs</li> <li>Map the <code>reset</code> input to a push-button or switch</li> <li>Map the <code>clock</code> input to the clock source</li> </ul> </li> <li> <p>Run the synthesis process.</p> </li> <li> <p>Generate the bitstream and, once completed, program the FPGA with it.</p> </li> </ol> <p>The LEDs should start blinking once you've finished programming the FPGA!</p>"},{"location":"examples/freertos/#featured-boards","title":"Featured boards","text":"<p>We provide project files for some featured FPGA boards. If you have one of the boards listed below, please follow the specific steps for your board:</p>"},{"location":"examples/freertos/#arty-a7","title":"Arty A7","text":"<ul> <li> <p>Build the FreeRTOS application as instructed in Building the example</p> <p>Use <code>CLOCK_FREQUENCY=50000000</code>.</p> </li> <li> <p>On AMD Vivado, click Tools / Run Tcl Script</p> <p>Select <code>examples/freertos/boards/arty_a7/create_project_arty_a7_&lt;variant&gt;.tcl</code>, where <code>&lt;variant&gt;</code> is the variant of your board (either 35T or 100T).</p> </li> <li> <p>Click Generate Bitstream and program the FPGA as usual</p> </li> <li>The LEDs should start blinking once you've finished programming the FPGA!</li> </ul>"},{"location":"examples/freertos/#cmod-a7","title":"Cmod A7","text":"<ul> <li> <p>Build the FreeRTOS application as instructed in Building the example</p> <p>Use <code>CLOCK_FREQUENCY=12000000</code>.</p> </li> <li> <p>On AMD Vivado, click Tools / Run Tcl Script</p> <p>Select <code>examples/freertos/boards/cmod_a7/create_project_cmod_a7.tcl</code>.</p> </li> <li> <p>Click Generate Bitstream and program the FPGA as usual</p> </li> <li>The LEDs should start blinking once you've finished programming the FPGA!</li> </ul> <p> </p>"},{"location":"examples/helloworld/","title":"Hello World Example","text":""},{"location":"examples/helloworld/#introduction","title":"Introduction","text":"<p>The Hello World example is a bare-metal application that uses the UART controller of RVX to send a Hello World message to a host computer.</p>"},{"location":"examples/helloworld/#prerequisites","title":"Prerequisites","text":"<p>To run this example, you need an FPGA board that has a UART-USB bridge, a common feature on most FPGAs.</p> <p>Additionally, you need to have the RISC-V GNU Toolchain installed on your machine to build the example. You can find instructions on how to install the RISC-V GNU Toolchain in the User Guide.</p>"},{"location":"examples/helloworld/#building-the-example","title":"Building the example","text":"<p>Run the commands below to build the Hello World example:</p> 1. Clone RVX repository<pre><code>git clone https://github.com/rafaelcalcada/rvx\n</code></pre> 2. Build the software for the Hello World example<pre><code>cd rvx/examples/hello_world/software &amp;&amp; make PREFIX=/opt/riscv\n</code></pre> <p>The <code>PREFIX</code> variable must specify the folder where the RISC-V GNU Toolchain is installed.</p> <p>A successfull build ends with a message like this:</p> Successful build report<pre><code>Memory init file:   build/hello_world.hex\nBinary executable:  build/hello_world.elf\nDisassembly:        build/hello_world.objdump\n\nMemory usage report (MEMORY_SIZE = 8K)\n      text       data        bss      total filename\n       240          0          0        240 hello_world.elf\n</code></pre> <p>The <code>hello_world.hex</code> file generated by the build process will be used in the next step to initialize the memory of RVX.</p>"},{"location":"examples/helloworld/#implementing-on-an-fpga","title":"Implementing on an FPGA","text":"Creating the Hello World module <p>Using your preferred text editor, create a Verilog file name <code>hello_world.v</code> and add the source code below. Make sure to modify <code>hello_world.v</code> as follows:</p> <ul> <li>Change the <code>MEMORY_INIT_FILE</code> parameter to the absolute path of the <code>hello_world.hex</code> file you generated in the previous step.</li> <li>Change the <code>CLOCK_FREQUENCY</code> parameter to the frequency (in Hertz) of the <code>clock</code> input.</li> </ul> hello_world.v<pre><code>module hello_world (\n\n  input   wire clock,\n  input   wire reset,\n  output  wire uart_tx\n\n  );\n\n  // Reset button debouncing\n  reg reset_debounced;\n  always @(posedge clock) begin\n    reset_debounced &lt;= reset;\n  end\n\n  rvx #(\n\n  // Please adjust these two parameters accordingly\n  .CLOCK_FREQUENCY          (50000000                   ),\n  .MEMORY_INIT_FILE         (\"/path/to/hello_world.hex\" )\n\n  ) rvx_instance (\n\n  .clock                    (clock                      ),\n  .reset                    (reset_debounced            ),\n  .uart_tx                  (uart_tx                    ),\n\n  // Unused inputs need to be hardwired to zero\n  .halt                     (1'b0                       ),\n  .uart_rx                  (1'b0                       ),\n  .gpio_input               (1'b0                       ),\n  .poci                     (1'b0                       ),\n\n  // Unused outputs can be left open  \n  .gpio_oe                  (                           ),\n  .gpio_output              (                           ),\n  .sclk                     (                           ),\n  .pico                     (                           ),  \n  .cs                       (                           ));\n\nendmodule\n</code></pre> Synthesizing the Hello World module <p>To implement the <code>hello_world.v</code> module on your FPGA, follow the steps below:</p> <ol> <li> <p>Open the EDA tool provided by your FPGA vendor (e.g., AMD Vivado, Intel Quartus, Lattice iCEcube).</p> </li> <li> <p>Include <code>hello_world.v</code> to the project and all files in the <code>hardware/</code> folder of RVX repository.</p> </li> <li> <p>Create a design constraints file and map the ports of <code>hello_world.v</code> to the corresponding devices on the FPGA board.</p> <ul> <li>Map the <code>uart_tx</code> output to the UART-USB bridge</li> <li>Map the <code>reset</code> input to a push-button or switch</li> <li>Map the <code>clock</code> input to the clock source</li> </ul> </li> <li> <p>Run the synthesis process.</p> </li> <li> <p>Generate the bitstream and, once completed, program the FPGA with it.</p> </li> </ol>"},{"location":"examples/helloworld/#running-the-application","title":"Running the application","text":"<p>Now that the FPGA is programmed, you can see the Hello World message on a host computer with the help of a serial terminal emulator like PySerial:</p> <ul> <li>Connect the FPGA board to your computer</li> <li> <p>Install PySerial (or other serial terminal emulator):</p> <pre><code>python3 -m pip install pyserial\n</code></pre> </li> <li> <p>Open a serial terminal</p> <p>With PySerial, a serial terminal can be opened by running:</p> <pre><code>python3 -m serial.tools.miniterm\n</code></pre> <p>PySerial will show the available serial ports, one of which is the UART-USB bridge of the FPGA board. Choose it to connect.</p> </li> <li> <p>Finally, press the reset button.</p> </li> </ul> <p>You should now see the Hello World message!</p>"},{"location":"examples/helloworld/#featured-boards","title":"Featured boards","text":"<p>We provide project files for some featured FPGA boards. If you have one of the boards listed below, please follow the specific steps for your board:</p>"},{"location":"examples/helloworld/#arty-a7","title":"Arty A7","text":"<ul> <li>Build the Hello World application as instructed in Building the example</li> <li> <p>On AMD Vivado, click Tools / Run Tcl Script</p> <p>Select <code>examples/hello_world/boards/arty_a7/create_project_arty_a7_&lt;variant&gt;.tcl</code>, where <code>&lt;variant&gt;</code> is the variant of your board (either 35T or 100T).</p> </li> <li> <p>Click Generate Bitstream and program the FPGA as usual</p> </li> <li>Run the example as instructed in Running the application</li> </ul>"},{"location":"examples/helloworld/#cmod-a7","title":"Cmod A7","text":"<ul> <li>Build the Hello World application as instructed in Building the example</li> <li> <p>On AMD Vivado, click Tools / Run Tcl Script</p> <p>Select <code>examples/hello_world/boards/cmod_a7/create_project_cmod_a7.tcl</code>.</p> </li> <li> <p>Click Generate Bitstream and program the FPGA as usual</p> </li> <li>Run the example as instructed in Running the application</li> </ul> <p> </p>"}]}